# IFG Project – Hardware Optimization Tasks

This repository contains theoretical and experimental parameters for the IFG project.  
Your task is to support *hardware-level design automation* for key quantum components.

## Scope

You are to implement calculations, simulations, and optimizations for:

1. **μ-cavity (microwave cavity) design**
   - Maximize quality factor Q
   - Minimize mode volume V
   - Ensure impedance matching with Qubit chip interface

2. **Flux-pump resonance optimization**
   - Given target g_{LS} = 0.17 ± 0.03
   - Explore drive amplitude/frequency/phase parameter space
   - Output: Gain profile, bandwidth, g_{LS} stability zones

3. **SQUID coupling**
   - Model mutual inductance with Qubit + cavity
   - Optimize loop size and position for max ΔB sensitivity

4. **16-Qubit layout auto-generation**
   - Layout with:
     - Bus resonator architecture (shared + local)
     - Minimal crosstalk (< -50 dB)
   - Output: chip geometry (coordinates), parasitic estimation

## Parameters

Refer to param_table_v0.3.6_FULL.txt for constraints.  
Use representative values unless instructed otherwise:

- Target cavity Q: \(6 \times 10^6\)
- Target V_mode: ~0.05 cm³
- SQUID sensitivity: 0.45 pT/√Hz
- Optical cavity: \(κ_{\text{geom}} ≈ 2.3 × 10^{-3}\)

## Expected Output

For each task, produce:
- Equation derivation (if needed)
- Python code (simulation or solver)
- CSV or JSON data output
- Brief comment block explaining the assumptions

All units should be SI or convertible.

If in doubt, default to quantum computing design conventions.

## Extra Instructions

- Use `scipy.optimize` for parameter search
- For layout generation, assume 2D chip area 10mm x 10mm
- Avoid overlapping control lines and readout lines
- Store all figures as PNG + source as matplotlib

## Generating cavity data

Run the μ-cavity simulation script to produce the result plot:

```bash
python src/simulate_muCavity.py
```

The script outputs `result/q_vs_r.json` (kept in plain JSON format) and
creates `docs/plot/mode_volume_vs_q.png`. The image file is not tracked
in the repository and is listed in `.gitignore`.




## μ-Cavity Optimization Results
This section summarizes the simulation results from `opt_design.json`.

| Radius (cm) | Height (cm) | Q | Mode Volume (cm³) | Q / V |
|-------------|-------------|--------------|-------------------|------------------|
| 0.22000000000000003 | 0.05 | 5212890.3 | 0.007603 | 685667161.17 |

Full results are stored in [`result/opt_design.json`](result/opt_design.json).

```bash
python src/simulate_muCavity.py
```

## Flux-Pump Scan
This repository also includes a simple flux-pump parametric amplification model.
Run the script below to generate an interaction map and JSON data:

```bash
python src/simulate_fluxpump.py
```

The program stores all scan points in `result/fluxpump_scan.json` and
produces a heatmap image at `docs/plot/fluxpump_gLS_heatmap.png`.
The heatmap is generated by the script and ignored in version control.

## 16-Qubit Layout Generator
To compute an example placement for the superconducting chip, run:

```bash
python src/layout_16Q_auto.py
```

Add ``--hex`` to use a hexagonal arrangement or ``--pitch`` to change the
qubit spacing. The script writes the coordinates to
`result/qubit_layout_map.txt` in plain text.

## Qubit-State Mapper

To automatically assign logical states (e.g., ψ₀, ψ₁, ...) to physical Qubit positions
defined in `result/qubit_layout_map.txt`, run:

```bash
python src/map_state_to_layout.py
```

This script creates a file `result/qubit_state_map.txt` with lines like:

```
Q0: (0.0, 0.0) → ψ₀
Q1: (1.0, 0.0) → ψ₁
...
```

It uses the layout file and assigns states sequentially.
If needed, you can pass `--states` to customize the number or naming of states.

Example:

```bash
python src/map_state_to_layout.py --states ψ₀ ψ₁ ψ₂ ψ₃ ψ₄ ψ₅ ψ₆ ψ₇ ψ₈ ψ₉ ψ₁₀ ψ₁₁ ψ₁₂ ψ₁₃ ψ₁₄ ψ₁₅
```

The mapping routine checks that the number of provided state labels matches the
number of qubits and orders qubits numerically (``Q0``, ``Q1`` ... ``Q15``).

## Coupling Candidate Inference

To determine which logical qubit pairs are likely to be physically coupled, run:

```bash
python src/infer_coupling_candidates.py
```

This program reads `result/logic_physical_map.json` and calculates the
Euclidean distance between all pairs of logical states. The results are saved
to `result/coupling_candidates.json` and a short summary is printed after
completion.

## All-Pairs Path Matrix

Run the path matrix generator to record the shortest routes between every
logical state pair:

```bash
python src/gen_allpair_paths.py
```

The program loads the logical-to-physical mapping and coupling table, performs
BFS from each node, and saves the results to `result/path_matrix.json`.

```
# Task: 全論理状態ペア間の最短経路を推定し、JSONに保存する
# Codexくんにお願い：

# 使用ファイル
- 入力: result/logic_physical_map.json（ノード情報）
- 入力: result/coupling_candidates.json（結合判定）
- 出力: result/path_matrix.json（ψᵢ → ψⱼ の最短経路）

# 要求仕様
- logical_index(ψₙ) に基づく昇順でノードを処理
- BFSで最短経路（中間ノード含む）をリスト形式で出力
- 全ノード間の経路を記録し、JSONに保存する
- 辞書型で ψᵢ → { ψⱼ: [経路] } の形を取る
- エンコードはUTF-8、JSONはインデント付きで保存
- ファイル名は固定：result/path_matrix.json
#
# 実行ファイル例
python src/gen_allpair_paths.py
```

## QASM Execution Trace Visualization

To visualize how the generated QASM executes step-by-step, run:

```bash
python src/simulate_qasm.py --json
python src/render_qasm_trace.py
```

These steps will:

- Simulate the execution of `result/iirb_swap_resolved.qasm`
- Log each SWAP/CX operation and full qubit state to `result/qasm_trace.json`
- Render each step as an image (`docs/plot/qasm_trace_step_XXX.png`)
- Combine the images into an animated GIF: `result/qasm_trace.gif`

Each image includes:

- Step number, gate type, and target qubits
- Visualized 16-qubit states, where:
  - 🟩 represents 1
  - ⬛ represents 0

⚠️ Requires the Pillow library (install with `pip install pillow`)


## Semantic Coupling Visualization

These utility scripts work with `result/semantic_coupling_map.json` to inspect how logical states relate semantically.

```bash
python src/gen_semantic_weights.py
python src/plot_semantic_coupling_graph.py
python src/gen_semantic_tensor.py
python src/simulate_semantic_spread.py
```

Generated files:
- `docs/plot/semantic_coupling_graph.png`
- `result/semantic_tensor.csv`
- `result/semantic_tensor.json`
- `result/semantic_spread_steps.json`
- `docs/plot/semantic_spread_step5.png`

## 📄 Reports

- [Executive Summary v1.0 (2025-05-31)](docs/reports/IFG_Executive_Summary_FINAL_v1.0_2025-05-31.md)
- [IFG Report v1.1](docs/report/IFG_Report_v1.1.md)

diff --git a/README.md b/README.md
index 2d72b449e4d7bd5c6359ddef263d31f8b9c373a3..e4306510d84cc3c90b58dde542f21a67464dfc87 100644
--- a/README.md
+++ b/README.md
@@ -207,25 +207,33 @@ Each image includes:
 
 ⚠️ Requires the Pillow library (install with `pip install pillow`)
 
 
 ## Semantic Coupling Visualization
 
 These utility scripts work with `result/semantic_coupling_map.json` to inspect how logical states relate semantically.
 
 ```bash
 python src/gen_semantic_weights.py
 python src/plot_semantic_coupling_graph.py
 python src/gen_semantic_tensor.py
 python src/simulate_semantic_spread.py
 ```
 
 Generated files:
 - `docs/plot/semantic_coupling_graph.png`
 - `result/semantic_tensor.csv`
 - `result/semantic_tensor.json`
 - `result/semantic_spread_steps.json`
 - `docs/plot/semantic_spread_step5.png`
 
 ## 📄 Reports
 
 - [Executive Summary v1.0 (2025-05-31)](docs/reports/IFG_Executive_Summary_FINAL_v1.0_2025-05-31.md)
+
+## 新規追加ツール
+
+- `tools/dimension_check.py`：第3章 §3.1–§3.2 の寸法解析を行う Python スクリプト
+  実行例：`python tools/dimension_check.py` → "dimensionless: True" を確認
+- `docs/table/dimension_analysis.md`：パラメータの次元・代表値をまとめた表（旧 .xlsx を Markdown 形式に移行）
+- `archives/dimension_analysis.xlsx`：旧Excel版は archives に移動済
+- `docs/table/Vq_frequency_list.md`：ポテンシャル $V(q)$ の各軸周波数リスト
+- `docs/table/boost_validation_plan.md`：ブースト検証計画をまとめた Markdown テーブル
+- `archive/legacy_paths/path_table_from_ψ0.json`：旧形式の論理パステーブル

## 📊 Simulation Tools

- `tools/cavity_optimize.py`：μ-cavity の Q×モード体積最適化ツール
- `tools/squid_coupler.py`：SQUID相互インダクタンス最適化
- `tools/fluxpump_optimize.py`：g_LS & BW を最大化するポンプ制御最適化
- `tools/dd_simulation.py`：DDシーケンスのデコヒーレンス抑制効果シミュレーター

docs/plot/ 以下に各スクリプト出力結果（matplotlib 画像など）を格納し、IFG_Report_v1.1.md（または第4・5章）に埋め込みます。
📝 NOTE: レポート本文に含まれる図は、`tools/*.py` を実行して生成されます。CI/CD 環境またはローカルでスクリプトを走らせ、`docs/plot/` 以下に PNG を作成してからコミットしてください。

## Measurement Analysis Utilities

Install dependencies with `pip install -r requirements.txt`\*.

\*`qutip` is omitted from the requirements for now but may be used in future scripts.

Example usage:

```bash
python src/compute_noise_spectrum.py noise.csv result/noise_fit.json --res-threshold 0.1
# '--res-threshold' controls the residual/variance warning level
python src/extract_quantum_metrics.py resonance.csv result/metrics.json
python src/extract_t2_from_dd.py dd.csv result/t2.json --save-plot --plot-path docs/plot/fig6_3.png
python src/sim_cooling_heatload.py --config result/heatload_layers.json --out-json result/heatload.json --plot-path docs/plot/fig6_4.png
python src/visualize_results.py result/metrics.json result/noise_fit.json result/t2.json --out-dir docs/plot
```

`sim_cooling_heatload.py` works without arguments using the same defaults as above, but the example shows them explicitly for clarity.

`extract_quantum_metrics.py` accepts CSV files with either a `freq` column (GHz) or a `timestamp` column converted to frequency. Amplitude can come from `I`/`Q` or an `abs` column.

## Chapter 7: Compare experiment vs theory

Example usage:

```bash
# Chapter 7: Compare experiment vs theory
python src/compare_resonance.py data/resonance_experiment.csv result/metrics.json --out docs/plot/fig7_1.png
python src/compare_noise.py result/noise_fit.json result/theory_noise.json --out docs/plot/fig7_2.png
python src/compare_dd_decay.py data/dd_experiment.csv result/t2.json --out docs/plot/fig7_3.png
python src/generate_error_analysis_flow.py --out docs/plot/fig7_4.png

# Parameter mapping
python src/fit_theory_experiment_mapping.py result/theory_params_init.json result/metrics.json result/t2.json result/noise_fit.json result/temperature_drift.csv result/heatload.json result/theory_params_validated.json
```
