# IFG Project â€“ Hardware Optimization Tasks

This repository contains theoretical and experimental parameters for the IFG project.  
Your task is to support *hardware-level design automation* for key quantum components.

## Scope

You are to implement calculations, simulations, and optimizations for:

1. **Î¼-cavity (microwave cavity) design**
   - Maximize quality factor Q
   - Minimize mode volume V
   - Ensure impedance matching with Qubit chip interface

2. **Flux-pump resonance optimization**
   - Given target g_{LS} = 0.17 Â± 0.03
   - Explore drive amplitude/frequency/phase parameter space
   - Output: Gain profile, bandwidth, g_{LS} stability zones

3. **SQUID coupling**
   - Model mutual inductance with Qubit + cavity
   - Optimize loop size and position for max Î”B sensitivity

4. **16-Qubit layout auto-generation**
   - Layout with:
     - Bus resonator architecture (shared + local)
     - Minimal crosstalk (< -50 dB)
   - Output: chip geometry (coordinates), parasitic estimation

## Parameters

Refer to param_table_v0.3.6_FULL.txt for constraints.  
Use representative values unless instructed otherwise:

- Target cavity Q: \(6 \times 10^6\)
- Target V_mode: ~0.05 cmÂ³
- SQUID sensitivity: 0.45 pT/âˆšHz
- Optical cavity: \(Îº_{\text{geom}} â‰ˆ 2.3 Ã— 10^{-3}\)

## Expected Output

For each task, produce:
- Equation derivation (if needed)
- Python code (simulation or solver)
- CSV or JSON data output
- Brief comment block explaining the assumptions

All units should be SI or convertible.

If in doubt, default to quantum computing design conventions.

## Extra Instructions

- Use `scipy.optimize` for parameter search
- For layout generation, assume 2D chip area 10mm x 10mm
- Avoid overlapping control lines and readout lines
- Store all figures as PNG + source as matplotlib

## Generating cavity data

Run the Î¼-cavity simulation script to produce the result plot:

```bash
python src/simulate_muCavity.py
```

The script outputs `result/q_vs_r.json` (kept in plain JSON format) and
creates `docs/plot/mode_volume_vs_q.png`. The image file is not tracked
in the repository and is listed in `.gitignore`.




## Î¼-Cavity Optimization Results
This section summarizes the simulation results from `opt_design.json`.

| Radius (cm) | Height (cm) | Q | Mode Volume (cmÂ³) | Q / V |
|-------------|-------------|--------------|-------------------|------------------|
| 0.22000000000000003 | 0.05 | 5212890.3 | 0.007603 | 685667161.17 |

Full results are stored in [`result/opt_design.json`](result/opt_design.json).

```bash
python src/simulate_muCavity.py
```

## Flux-Pump Scan
This repository also includes a simple flux-pump parametric amplification model.
Run the script below to generate an interaction map and JSON data:

```bash
python src/simulate_fluxpump.py
```

The program stores all scan points in `result/fluxpump_scan.json` and
produces a heatmap image at `docs/plot/fluxpump_gLS_heatmap.png`.
The heatmap is generated by the script and ignored in version control.

## 16-Qubit Layout Generator
To compute an example placement for the superconducting chip, run:

```bash
python src/layout_16Q_auto.py
```

Add ``--hex`` to use a hexagonal arrangement or ``--pitch`` to change the
qubit spacing. The script writes the coordinates to
`result/qubit_layout_map.txt` in plain text.

## Qubit-State Mapper

To automatically assign logical states (e.g., Ïˆâ‚€, Ïˆâ‚, ...) to physical Qubit positions
defined in `result/qubit_layout_map.txt`, run:

```bash
python src/map_state_to_layout.py
```

This script creates a file `result/qubit_state_map.txt` with lines like:

```
Q0: (0.0, 0.0) â†’ Ïˆâ‚€
Q1: (1.0, 0.0) â†’ Ïˆâ‚
...
```

It uses the layout file and assigns states sequentially.
If needed, you can pass `--states` to customize the number or naming of states.

Example:

```bash
python src/map_state_to_layout.py --states Ïˆâ‚€ Ïˆâ‚ Ïˆâ‚‚ Ïˆâ‚ƒ Ïˆâ‚„ Ïˆâ‚… Ïˆâ‚† Ïˆâ‚‡ Ïˆâ‚ˆ Ïˆâ‚‰ Ïˆâ‚â‚€ Ïˆâ‚â‚ Ïˆâ‚â‚‚ Ïˆâ‚â‚ƒ Ïˆâ‚â‚„ Ïˆâ‚â‚…
```

The mapping routine checks that the number of provided state labels matches the
number of qubits and orders qubits numerically (``Q0``, ``Q1`` ... ``Q15``).

## Coupling Candidate Inference

To determine which logical qubit pairs are likely to be physically coupled, run:

```bash
python src/infer_coupling_candidates.py
```

This program reads `result/logic_physical_map.json` and calculates the
Euclidean distance between all pairs of logical states. The results are saved
to `result/coupling_candidates.json` and a short summary is printed after
completion.

## All-Pairs Path Matrix

Run the path matrix generator to record the shortest routes between every
logical state pair:

```bash
python src/gen_allpair_paths.py
```

The program loads the logical-to-physical mapping and coupling table, performs
BFS from each node, and saves the results to `result/path_matrix.json`.

```
# Task: å…¨è«–ç†çŠ¶æ…‹ãƒšã‚¢é–“ã®æœ€çŸ­çµŒè·¯ã‚’æŽ¨å®šã—ã€JSONã«ä¿å­˜ã™ã‚‹
# Codexãã‚“ã«ãŠé¡˜ã„ï¼š

# ä½¿ç”¨ãƒ•ã‚¡ã‚¤ãƒ«
- å…¥åŠ›: result/logic_physical_map.jsonï¼ˆãƒŽãƒ¼ãƒ‰æƒ…å ±ï¼‰
- å…¥åŠ›: result/coupling_candidates.jsonï¼ˆçµåˆåˆ¤å®šï¼‰
- å‡ºåŠ›: result/path_matrix.jsonï¼ˆÏˆáµ¢ â†’ Ïˆâ±¼ ã®æœ€çŸ­çµŒè·¯ï¼‰

# è¦æ±‚ä»•æ§˜
- logical_index(Ïˆâ‚™) ã«åŸºã¥ãæ˜‡é †ã§ãƒŽãƒ¼ãƒ‰ã‚’å‡¦ç†
- BFSã§æœ€çŸ­çµŒè·¯ï¼ˆä¸­é–“ãƒŽãƒ¼ãƒ‰å«ã‚€ï¼‰ã‚’ãƒªã‚¹ãƒˆå½¢å¼ã§å‡ºåŠ›
- å…¨ãƒŽãƒ¼ãƒ‰é–“ã®çµŒè·¯ã‚’è¨˜éŒ²ã—ã€JSONã«ä¿å­˜ã™ã‚‹
- è¾žæ›¸åž‹ã§ Ïˆáµ¢ â†’ { Ïˆâ±¼: [çµŒè·¯] } ã®å½¢ã‚’å–ã‚‹
- ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã¯UTF-8ã€JSONã¯ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆä»˜ãã§ä¿å­˜
- ãƒ•ã‚¡ã‚¤ãƒ«åã¯å›ºå®šï¼šresult/path_matrix.json
#
# å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ä¾‹
python src/gen_allpair_paths.py
```

## QASM Execution Trace Visualization

To visualize how the generated QASM executes step-by-step, run:

```bash
python src/simulate_qasm.py --json
python src/render_qasm_trace.py
```

These steps will:

- Simulate the execution of `result/iirb_swap_resolved.qasm`
- Log each SWAP/CX operation and full qubit state to `result/qasm_trace.json`
- Render each step as an image (`docs/plot/qasm_trace_step_XXX.png`)
- Combine the images into an animated GIF: `result/qasm_trace.gif`

Each image includes:

- Step number, gate type, and target qubits
- Visualized 16-qubit states, where:
  - ðŸŸ© represents 1
  - â¬› represents 0

âš ï¸ Requires the Pillow library (install with `pip install pillow`)


## Semantic Coupling Visualization

These utility scripts work with `result/semantic_coupling_map.json` to inspect how logical states relate semantically.

```bash
python src/gen_semantic_weights.py
python src/plot_semantic_coupling_graph.py
python src/gen_semantic_tensor.py
python src/simulate_semantic_spread.py
```

Generated files:
- `docs/plot/semantic_coupling_graph.png`
- `result/semantic_tensor.csv`
- `result/semantic_tensor.json`
- `result/semantic_spread_steps.json`
- `docs/plot/semantic_spread_step5.png`

## ðŸ“„ Reports

- [Executive Summary v1.0 (2025-05-31)](docs/reports/IFG_Executive_Summary_FINAL_v1.0_2025-05-31.md)
- [IFG Report v1.1](docs/report/IFG_Report_v1.1.md)

diff --git a/README.md b/README.md
index 2d72b449e4d7bd5c6359ddef263d31f8b9c373a3..e4306510d84cc3c90b58dde542f21a67464dfc87 100644
--- a/README.md
+++ b/README.md
@@ -207,25 +207,33 @@ Each image includes:
 
 âš ï¸ Requires the Pillow library (install with `pip install pillow`)
 
 
 ## Semantic Coupling Visualization
 
 These utility scripts work with `result/semantic_coupling_map.json` to inspect how logical states relate semantically.
 
 ```bash
 python src/gen_semantic_weights.py
 python src/plot_semantic_coupling_graph.py
 python src/gen_semantic_tensor.py
 python src/simulate_semantic_spread.py
 ```
 
 Generated files:
 - `docs/plot/semantic_coupling_graph.png`
 - `result/semantic_tensor.csv`
 - `result/semantic_tensor.json`
 - `result/semantic_spread_steps.json`
 - `docs/plot/semantic_spread_step5.png`
 
 ## ðŸ“„ Reports
 
 - [Executive Summary v1.0 (2025-05-31)](docs/reports/IFG_Executive_Summary_FINAL_v1.0_2025-05-31.md)
+
+## æ–°è¦è¿½åŠ ãƒ„ãƒ¼ãƒ«
+
+- `tools/dimension_check.py`ï¼šç¬¬3ç«  Â§3.1â€“Â§3.2 ã®å¯¸æ³•è§£æžã‚’è¡Œã† Python ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
+  å®Ÿè¡Œä¾‹ï¼š`python tools/dimension_check.py` â†’ "dimensionless: True" ã‚’ç¢ºèª
+- `docs/table/dimension_analysis.md`ï¼šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¬¡å…ƒãƒ»ä»£è¡¨å€¤ã‚’ã¾ã¨ã‚ãŸè¡¨ï¼ˆæ—§ .xlsx ã‚’ Markdown å½¢å¼ã«ç§»è¡Œï¼‰
+- `archives/dimension_analysis.xlsx`ï¼šæ—§Excelç‰ˆã¯ archives ã«ç§»å‹•æ¸ˆ
+- `docs/table/Vq_frequency_list.md`ï¼šãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« $V(q)$ ã®å„è»¸å‘¨æ³¢æ•°ãƒªã‚¹ãƒˆ
+- `docs/table/boost_validation_plan.md`ï¼šãƒ–ãƒ¼ã‚¹ãƒˆæ¤œè¨¼è¨ˆç”»ã‚’ã¾ã¨ã‚ãŸ Markdown ãƒ†ãƒ¼ãƒ–ãƒ«
+- `archive/legacy_paths/path_table_from_Ïˆ0.json`ï¼šæ—§å½¢å¼ã®è«–ç†ãƒ‘ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«

## ðŸ“Š Simulation Tools

- `tools/cavity_optimize.py`ï¼šÎ¼-cavity ã® QÃ—ãƒ¢ãƒ¼ãƒ‰ä½“ç©æœ€é©åŒ–ãƒ„ãƒ¼ãƒ«
- `tools/squid_coupler.py`ï¼šSQUIDç›¸äº’ã‚¤ãƒ³ãƒ€ã‚¯ã‚¿ãƒ³ã‚¹æœ€é©åŒ–
- `tools/fluxpump_optimize.py`ï¼šg_LS & BW ã‚’æœ€å¤§åŒ–ã™ã‚‹ãƒãƒ³ãƒ—åˆ¶å¾¡æœ€é©åŒ–
- `tools/dd_simulation.py`ï¼šDDã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ãƒ‡ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹æŠ‘åˆ¶åŠ¹æžœã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼

docs/plot/ ä»¥ä¸‹ã«å„ã‚¹ã‚¯ãƒªãƒ—ãƒˆå‡ºåŠ›çµæžœï¼ˆmatplotlib ç”»åƒãªã©ï¼‰ã‚’æ ¼ç´ã—ã€IFG_Report_v1.1.mdï¼ˆã¾ãŸã¯ç¬¬4ãƒ»5ç« ï¼‰ã«åŸ‹ã‚è¾¼ã¿ã¾ã™ã€‚
ðŸ“ NOTE: ãƒ¬ãƒãƒ¼ãƒˆæœ¬æ–‡ã«å«ã¾ã‚Œã‚‹å›³ã¯ã€`tools/*.py` ã‚’å®Ÿè¡Œã—ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚CI/CD ç’°å¢ƒã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«ã§ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’èµ°ã‚‰ã›ã€`docs/plot/` ä»¥ä¸‹ã« PNG ã‚’ä½œæˆã—ã¦ã‹ã‚‰ã‚³ãƒŸãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚

## Measurement Analysis Utilities

Install dependencies with `pip install -r requirements.txt`\*.

\*`qutip` is omitted from the requirements for now but may be used in future scripts.

Example usage:

```bash
python src/compute_noise_spectrum.py noise.csv result/noise_fit.json --res-threshold 0.1
# '--res-threshold' controls the residual/variance warning level
python src/extract_quantum_metrics.py resonance.csv result/metrics.json
python src/extract_t2_from_dd.py dd.csv result/t2.json --save-plot --plot-path docs/plot/fig6_3.png
python src/sim_cooling_heatload.py --config result/heatload_layers.json --out-json result/heatload.json --plot-path docs/plot/fig6_4.png
python src/visualize_results.py result/metrics.json result/noise_fit.json result/t2.json --out-dir docs/plot
```

`sim_cooling_heatload.py` works without arguments using the same defaults as above, but the example shows them explicitly for clarity.

`extract_quantum_metrics.py` accepts CSV files with either a `freq` column (GHz) or a `timestamp` column converted to frequency. Amplitude can come from `I`/`Q` or an `abs` column.

## Chapter 7: Compare experiment vs theory

Example usage:

```bash
# Chapter 7: Compare experiment vs theory
python src/compare_resonance.py data/resonance_experiment.csv result/metrics.json --out docs/plot/fig7_1.png
python src/compare_noise.py result/noise_fit.json result/theory_noise.json --out docs/plot/fig7_2.png
python src/compare_dd_decay.py data/dd_experiment.csv result/t2.json --out docs/plot/fig7_3.png
python src/generate_error_analysis_flow.py --out docs/plot/fig7_4.png

# Parameter mapping
python src/fit_theory_experiment_mapping.py result/theory_params_init.json result/metrics.json result/t2.json result/noise_fit.json result/temperature_drift.csv result/heatload.json result/theory_params_validated.json
```
