# IFG Project – Hardware Optimization Tasks

This repository contains theoretical and experimental parameters for the IFG project.  
Your task is to support *hardware-level design automation* for key quantum components.

## Scope

You are to implement calculations, simulations, and optimizations for:

1. **μ-cavity (microwave cavity) design**
   - Maximize quality factor Q
   - Minimize mode volume V
   - Ensure impedance matching with Qubit chip interface

2. **Flux-pump resonance optimization**
   - Given target g_{LS} = 0.17 ± 0.03
   - Explore drive amplitude/frequency/phase parameter space
   - Output: Gain profile, bandwidth, g_{LS} stability zones

3. **SQUID coupling**
   - Model mutual inductance with Qubit + cavity
   - Optimize loop size and position for max ΔB sensitivity

4. **16-Qubit layout auto-generation**
   - Layout with:
     - Bus resonator architecture (shared + local)
     - Minimal crosstalk (< -50 dB)
   - Output: chip geometry (coordinates), parasitic estimation

## Parameters

Refer to param_table_v0.3.6_FULL.txt for constraints.  
Use representative values unless instructed otherwise:

- Target cavity Q: \(6 \times 10^6\)
- Target V_mode: ~0.05 cm³
- SQUID sensitivity: 0.45 pT/√Hz
- Optical cavity: \(κ_{\text{geom}} ≈ 2.3 × 10^{-3}\)

## Expected Output

For each task, produce:
- Equation derivation (if needed)
- Python code (simulation or solver)
- CSV or JSON data output
- Brief comment block explaining the assumptions

All units should be SI or convertible.

If in doubt, default to quantum computing design conventions.

## Extra Instructions

- Use `scipy.optimize` for parameter search
- For layout generation, assume 2D chip area 10mm x 10mm
- Avoid overlapping control lines and readout lines
- Store all figures as PNG + source as matplotlib

## Generating cavity data

Run the μ-cavity simulation script to produce the result plot:

```bash
python src/simulate_muCavity.py
```

The script outputs `result/q_vs_r.json` (kept in plain JSON format) and
creates `docs/plot/mode_volume_vs_q.png`. The image file is not tracked
in the repository and is listed in `.gitignore`.




## μ-Cavity Optimization Results
This section summarizes the simulation results from `opt_design.json`.

| Radius (cm) | Height (cm) | Q | Mode Volume (cm³) | Q / V |
|-------------|-------------|--------------|-------------------|------------------|
| 0.22000000000000003 | 0.05 | 5212890.3 | 0.007603 | 685667161.17 |

Full results are stored in [`result/opt_design.json`](result/opt_design.json).

```bash
python src/simulate_muCavity.py
```

## Flux-Pump Scan
This repository also includes a simple flux-pump parametric amplification model.
Run the script below to generate an interaction map and JSON data:

```bash
python src/simulate_fluxpump.py
```

The program stores all scan points in `result/fluxpump_scan.json` and
produces a heatmap image at `docs/plot/fluxpump_gLS_heatmap.png`.
The heatmap is generated by the script and ignored in version control.

## 16-Qubit Layout Generator
To compute an example placement for the superconducting chip, run:

```bash
python src/layout_16Q_auto.py
```

Add ``--hex`` to use a hexagonal arrangement or ``--pitch`` to change the
qubit spacing. The script writes the coordinates to
`result/qubit_layout_map.txt` in plain text.

## Qubit-State Mapper

To automatically assign logical states (e.g., ψ₀, ψ₁, ...) to physical Qubit positions
defined in `result/qubit_layout_map.txt`, run:

```bash
python src/map_state_to_layout.py
```

This script creates a file `result/qubit_state_map.txt` with lines like:

```
Q0: (0.0, 0.0) → ψ₀
Q1: (1.0, 0.0) → ψ₁
...
```

It uses the layout file and assigns states sequentially.
If needed, you can pass `--states` to customize the number or naming of states.

Example:

```bash
python src/map_state_to_layout.py --states ψ₀ ψ₁ ψ₂ ψ₃ ψ₄ ψ₅ ψ₆ ψ₇ ψ₈ ψ₉ ψ₁₀ ψ₁₁ ψ₁₂ ψ₁₃ ψ₁₄ ψ₁₅
```

The mapping routine checks that the number of provided state labels matches the
number of qubits and orders qubits numerically (``Q0``, ``Q1`` ... ``Q15``).

## Coupling Candidate Inference

To determine which logical qubit pairs are likely to be physically coupled, run:

```bash
python src/infer_coupling_candidates.py
```

This program reads `result/logic_physical_map.json` and calculates the
Euclidean distance between all pairs of logical states. The results are saved
to `result/coupling_candidates.json` and a short summary is printed after
completion.

## All-Pairs Path Matrix

Run the path matrix generator to record the shortest routes between every
logical state pair:

```bash
python src/gen_allpair_paths.py
```

The program loads the logical-to-physical mapping and coupling table, performs
BFS from each node, and saves the results to `result/path_matrix.json`.

```
# Task: 全論理状態ペア間の最短経路を推定し、JSONに保存する
# Codexくんにお願い：

# 使用ファイル
- 入力: result/logic_physical_map.json（ノード情報）
- 入力: result/coupling_candidates.json（結合判定）
- 出力: result/path_matrix.json（ψᵢ → ψⱼ の最短経路）

# 要求仕様
- logical_index(ψₙ) に基づく昇順でノードを処理
- BFSで最短経路（中間ノード含む）をリスト形式で出力
- 全ノード間の経路を記録し、JSONに保存する
- 辞書型で ψᵢ → { ψⱼ: [経路] } の形を取る
- エンコードはUTF-8、JSONはインデント付きで保存
- ファイル名は固定：result/path_matrix.json
#
# 実行ファイル例
python src/gen_allpair_paths.py
```

## QASM Execution Trace Visualization

To visualize how the generated QASM executes step-by-step, run:

```bash
python src/simulate_qasm.py --json
python src/render_qasm_trace.py
```

These steps will:

- Simulate the execution of `result/iirb_swap_resolved.qasm`
- Log each SWAP/CX operation and full qubit state to `result/qasm_trace.json`
- Render each step as an image (`docs/plot/qasm_trace_step_XXX.png`)
- Combine the images into an animated GIF: `result/qasm_trace.gif`

Each image includes:

- Step number, gate type, and target qubits
- Visualized 16-qubit states, where:
  - 🟩 represents 1
  - ⬛ represents 0

⚠️ Requires the Pillow library (install with `pip install pillow`)

