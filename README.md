# IFG Project â€“ Hardware Optimization Tasks

This repository contains theoretical and experimental parameters for the IFG project.  
Your task is to support *hardware-level design automation* for key quantum components.

## Scope

You are to implement calculations, simulations, and optimizations for:

1. **Î¼-cavity (microwave cavity) design**
   - Maximize quality factor Q
   - Minimize mode volume V
   - Ensure impedance matching with Qubit chip interface

2. **Flux-pump resonance optimization**
   - Given target g_{LS} = 0.17 Â± 0.03
   - Explore drive amplitude/frequency/phase parameter space
   - Output: Gain profile, bandwidth, g_{LS} stability zones

3. **SQUID coupling**
   - Model mutual inductance with Qubit + cavity
   - Optimize loop size and position for max Î”B sensitivity

4. **16-Qubit layout auto-generation**
   - Layout with:
     - Bus resonator architecture (shared + local)
     - Minimal crosstalk (< -50 dB)
   - Output: chip geometry (coordinates), parasitic estimation

## Parameters

Refer to param_table_v0.3.6_FULL.txt for constraints.  
Use representative values unless instructed otherwise:

- Target cavity Q: \(6 \times 10^6\)
- Target V_mode: ~0.05 cmÂ³
- SQUID sensitivity: 0.45 pT/âˆšHz
- Optical cavity: \(Îº_{\text{geom}} â‰ˆ 2.3 Ã— 10^{-3}\)

## Expected Output

For each task, produce:
- Equation derivation (if needed)
- Python code (simulation or solver)
- CSV or JSON data output
- Brief comment block explaining the assumptions

All units should be SI or convertible.

If in doubt, default to quantum computing design conventions.

## Extra Instructions

- Use `scipy.optimize` for parameter search
- For layout generation, assume 2D chip area 10mm x 10mm
- Avoid overlapping control lines and readout lines
- Store all figures as PNG + source as matplotlib

## Generating cavity data

Run the Î¼-cavity simulation script to produce the result plot:

```bash
python src/simulate_muCavity.py
```

The script outputs `result/q_vs_r.json` (kept in plain JSON format) and
creates `docs/plot/mode_volume_vs_q.png`. The image file is not tracked
in the repository and is listed in `.gitignore`.




## Î¼-Cavity Optimization Results
This section summarizes the simulation results from `opt_design.json`.

| Radius (cm) | Height (cm) | Q | Mode Volume (cmÂ³) | Q / V |
|-------------|-------------|--------------|-------------------|------------------|
| 0.22000000000000003 | 0.05 | 5212890.3 | 0.007603 | 685667161.17 |

Full results are stored in [`result/opt_design.json`](result/opt_design.json).

```bash
python src/simulate_muCavity.py
```

## Flux-Pump Scan
This repository also includes a simple flux-pump parametric amplification model.
Run the script below to generate an interaction map and JSON data:

```bash
python src/simulate_fluxpump.py
```

The program stores all scan points in `result/fluxpump_scan.json` and
produces a heatmap image at `docs/plot/fluxpump_gLS_heatmap.png`.
The heatmap is generated by the script and ignored in version control.

## 16-Qubit Layout Generator
To compute an example placement for the superconducting chip, run:

```bash
python src/layout_16Q_auto.py
```

Add ``--hex`` to use a hexagonal arrangement or ``--pitch`` to change the
qubit spacing. The script writes the coordinates to
`result/qubit_layout_map.txt` in plain text.

## Qubit-State Mapper

To automatically assign logical states (e.g., Ïˆâ‚€, Ïˆâ‚, ...) to physical Qubit positions
defined in `result/qubit_layout_map.txt`, run:

```bash
python src/map_state_to_layout.py
```

This script creates a file `result/qubit_state_map.txt` with lines like:

```
Q0: (0.0, 0.0) â†’ Ïˆâ‚€
Q1: (1.0, 0.0) â†’ Ïˆâ‚
...
```

It uses the layout file and assigns states sequentially.
If needed, you can pass `--states` to customize the number or naming of states.

Example:

```bash
python src/map_state_to_layout.py --states Ïˆâ‚€ Ïˆâ‚ Ïˆâ‚‚ Ïˆâ‚ƒ Ïˆâ‚„ Ïˆâ‚… Ïˆâ‚† Ïˆâ‚‡ Ïˆâ‚ˆ Ïˆâ‚‰ Ïˆâ‚â‚€ Ïˆâ‚â‚ Ïˆâ‚â‚‚ Ïˆâ‚â‚ƒ Ïˆâ‚â‚„ Ïˆâ‚â‚…
```

The mapping routine checks that the number of provided state labels matches the
number of qubits and orders qubits numerically (``Q0``, ``Q1`` ... ``Q15``).

## Coupling Candidate Inference

To determine which logical qubit pairs are likely to be physically coupled, run:

```bash
python src/infer_coupling_candidates.py
```

This program reads `result/logic_physical_map.json` and calculates the
Euclidean distance between all pairs of logical states. The results are saved
to `result/coupling_candidates.json` and a short summary is printed after
completion.

## All-Pairs Path Matrix

Run the path matrix generator to record the shortest routes between every
logical state pair:

```bash
python src/gen_allpair_paths.py
```

The program loads the logical-to-physical mapping and coupling table, performs
BFS from each node, and saves the results to `result/path_matrix.json`.

```
# Task: å…¨è«–ç†çŠ¶æ…‹ãƒšã‚¢é–“ã®æœ€çŸ­çµŒè·¯ã‚’æŽ¨å®šã—ã€JSONã«ä¿å­˜ã™ã‚‹
# Codexãã‚“ã«ãŠé¡˜ã„ï¼š

# ä½¿ç”¨ãƒ•ã‚¡ã‚¤ãƒ«
- å…¥åŠ›: result/logic_physical_map.jsonï¼ˆãƒŽãƒ¼ãƒ‰æƒ…å ±ï¼‰
- å…¥åŠ›: result/coupling_candidates.jsonï¼ˆçµåˆåˆ¤å®šï¼‰
- å‡ºåŠ›: result/path_matrix.jsonï¼ˆÏˆáµ¢ â†’ Ïˆâ±¼ ã®æœ€çŸ­çµŒè·¯ï¼‰

# è¦æ±‚ä»•æ§˜
- logical_index(Ïˆâ‚™) ã«åŸºã¥ãæ˜‡é †ã§ãƒŽãƒ¼ãƒ‰ã‚’å‡¦ç†
- BFSã§æœ€çŸ­çµŒè·¯ï¼ˆä¸­é–“ãƒŽãƒ¼ãƒ‰å«ã‚€ï¼‰ã‚’ãƒªã‚¹ãƒˆå½¢å¼ã§å‡ºåŠ›
- å…¨ãƒŽãƒ¼ãƒ‰é–“ã®çµŒè·¯ã‚’è¨˜éŒ²ã—ã€JSONã«ä¿å­˜ã™ã‚‹
- è¾žæ›¸åž‹ã§ Ïˆáµ¢ â†’ { Ïˆâ±¼: [çµŒè·¯] } ã®å½¢ã‚’å–ã‚‹
- ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã¯UTF-8ã€JSONã¯ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆä»˜ãã§ä¿å­˜
- ãƒ•ã‚¡ã‚¤ãƒ«åã¯å›ºå®šï¼šresult/path_matrix.json
#
# å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ä¾‹
python src/gen_allpair_paths.py
```

## QASM Execution Trace Visualization

To visualize how the generated QASM executes step-by-step, run:

```bash
python src/simulate_qasm.py --json
python src/render_qasm_trace.py
```

These steps will:

- Simulate the execution of `result/iirb_swap_resolved.qasm`
- Log each SWAP/CX operation and full qubit state to `result/qasm_trace.json`
- Render each step as an image (`docs/plot/qasm_trace_step_XXX.png`)
- Combine the images into an animated GIF: `result/qasm_trace.gif`

Each image includes:

- Step number, gate type, and target qubits
- Visualized 16-qubit states, where:
  - ðŸŸ© represents 1
  - â¬› represents 0

âš ï¸ Requires the Pillow library (install with `pip install pillow`)

